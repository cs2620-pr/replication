syntax = "proto3";

package replication;

// Service for server-to-server communication
service NodeCommunication {
  // Request vote from other nodes during an election
  rpc RequestVote (VoteRequest) returns (VoteResponse);
  
  // Send heartbeat/append entries to followers
  rpc AppendEntries (AppendEntriesRequest) returns (AppendEntriesResponse);
}

// Service for client-to-server communication
service DataService {
  // Set a key-value pair
  rpc Set (SetRequest) returns (SetResponse);
  
  // Get a value for a key
  rpc Get (GetRequest) returns (GetResponse);
}

// Monitoring and health check service
service MonitoringService {
  // Check if the node is healthy and serving
  rpc HealthCheck (HealthCheckRequest) returns (HealthCheckResponse);
  
  // Get detailed status of this node
  rpc NodeStatus (NodeStatusRequest) returns (NodeStatusResponse);
  
  // Get status of the entire cluster (only available from leader)
  rpc ClusterStatus (ClusterStatusRequest) returns (ClusterStatusResponse);
}

// Request vote message
message VoteRequest {
  int32 term = 1;             // Candidate's term
  int32 candidate_id = 2;     // Candidate requesting vote
  int32 last_log_index = 3;   // Index of candidate's last log entry
  int32 last_log_term = 4;    // Term of candidate's last log entry
}

// Vote response message
message VoteResponse {
  int32 term = 1;             // Current term, for candidate to update itself
  bool vote_granted = 2;      // True means candidate received vote
}

// Append entries (heartbeat) request
message AppendEntriesRequest {
  int32 term = 1;             // Leader's term
  int32 leader_id = 2;        // So follower can redirect clients
  int32 prev_log_index = 3;   // Index of log entry immediately preceding new ones
  int32 prev_log_term = 4;    // Term of prev_log_index entry
  repeated LogEntry entries = 5;  // Log entries to store (empty for heartbeat)
  int32 leader_commit = 6;    // Leader's commit index
}

// Log entry
message LogEntry {
  int32 term = 1;             // Term when entry was received by leader
  int32 index = 2;            // Position in the log
  bytes data = 3;             // Command data
}

// Append entries response
message AppendEntriesResponse {
  int32 term = 1;             // Current term, for leader to update itself
  bool success = 2;           // True if follower contained entry matching prev_log_index and prev_log_term
}

// Set request for key-value storage
message SetRequest {
  string key = 1;
  string value = 2;
}

// Set response
message SetResponse {
  bool success = 1;
  string message = 2;
}

// Get request for key-value storage
message GetRequest {
  string key = 1;
}

// Get response
message GetResponse {
  bool success = 1;
  string value = 2;
  string message = 3;
}

// Health check request (empty)
message HealthCheckRequest {
}

// Health check response
message HealthCheckResponse {
  enum ServingStatus {
    UNKNOWN = 0;
    SERVING = 1;
    NOT_SERVING = 2;
    SERVICE_UNKNOWN = 3;
  }
  ServingStatus status = 1;    // Current serving status
  string version = 2;          // Version information
  int64 uptime_seconds = 3;    // How long the service has been running
}

// Node status request
message NodeStatusRequest {
  bool include_log = 1;             // Whether to include log entries in response
  bool include_state_machine = 2;   // Whether to include state machine data
}

// Node status response
message NodeStatusResponse {
  message PeerStatus {
    int32 node_id = 1;              // ID of the peer node
    bool is_connected = 2;          // Whether we're currently connected to this peer
    int64 last_contact_ms = 3;      // Time since last successful communication (ms)
    int32 next_index = 4;           // Next log entry to send to that peer
    int32 match_index = 5;          // Highest log entry known to be replicated on peer
  }
  
  int32 node_id = 1;                // ID of this node
  int32 state = 2;                  // Current state (0=follower, 1=candidate, 2=leader)
  int32 current_term = 3;           // Current term
  int32 current_leader = 4;         // Current leader ID (if known)
  int32 committed_index = 5;        // Highest log entry known to be committed
  int32 last_applied = 6;           // Highest log entry applied to state machine
  int32 log_size = 7;               // Total size of the log
  repeated PeerStatus peers = 8;    // Status of each peer
  repeated LogEntry log = 9;        // Log entries (if requested)
  map<string, string> state_machine = 10;  // State machine data (if requested)
}

// Cluster status request
message ClusterStatusRequest {
  bool include_all_node_details = 1;  // Whether to include detailed status of all nodes
}

// Cluster status response
message ClusterStatusResponse {
  int32 leader_id = 1;              // ID of the current leader
  int32 current_term = 2;           // Current term
  int32 total_nodes = 3;            // Total number of nodes in the cluster
  int32 healthy_nodes = 4;          // Number of healthy nodes
  repeated NodeStatusResponse node_details = 5;  // Details of all nodes (if requested)
}
